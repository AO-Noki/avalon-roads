---
import Layout from '../layouts/Layout.astro';
import MapCard from '../components/MapCard.astro';
import ThemeToggle from '../components/ThemeToggle.astro';
import AdBanner from '../components/AdBanner.astro';
import type { Map, ChestType, DungeonType, ResourceType, ChestItem, DungeonItem, ResourceItem } from '../types/map';
import mapsData from '../data/maps.json';

// Usar os dados reais dos mapas e converter para o tipo correto
const maps: Map[] = mapsData.maps.map(map => ({
  ...map,
  chests: (map.chests || []).map(item => ({
    type: item.type as ChestType,
    size: item.size as 'small' | 'large',
    count: item.count
  })),
  dungeons: (map.dungeons || []).map(item => ({
    type: item.type as DungeonType,
    size: item.size as 'small' | 'large',
    count: item.count
  })),
  resources: (map.resources || []).map(item => ({
    type: item.type as ResourceType,
    size: item.size as 'small' | 'large',
    count: item.count
  }))
}));

// Obter todos os tipos de recursos para filtros
const chestTypes = Array.from(new Set(
  maps.flatMap(map => map.chests?.map(r => r.type) || [])
)).sort() as ChestType[];

const dungeonTypes = Array.from(new Set(
  maps.flatMap(map => map.dungeons?.map(r => r.type) || [])
)).sort() as DungeonType[];

const resourceTypes = Array.from(new Set(
  maps.flatMap(map => map.resources?.map(r => r.type) || [])
)).sort() as ResourceType[];

// Todos os tipos para filtros
const allResourceTypes = [...chestTypes, ...dungeonTypes, ...resourceTypes];

const tiers = Array.from(new Set(maps.map(map => map.tier))).sort();

// Data da última atualização
const lastUpdated = new Date(mapsData.lastUpdated || new Date()).toLocaleDateString('pt-BR', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

// Função para obter o ícone do recurso
const getResourceIcon = (type: string): string => {
  switch (type) {
    case 'BLUE': return '/icons/chest_blue.png';
    case 'GREEN': return '/icons/chest_green.png';
    case 'GOLD': return '/icons/chest_gold.png';
    case 'STONE': return '/icons/resource_stone.png';
    case 'DUNGEON_SOLO': return '/icons/dungeon_solo.png';
    case 'DUNGEON_GROUP': return '/icons/dungeon_group.png';
    case 'DUNGEON_AVALON': return '/icons/dungeon_avalon.png';
    case 'WOOD': return '/icons/resource_wood.png';
    case 'ORE': return '/icons/resource_ore.png';
    case 'HIDE': return '/icons/resource_hide.png';
    case 'FIBER': return '/icons/resource_fiber.png';
    default: return '/icons/resource_unknown.png';
  }
};
---

<Layout title="Avalon Roads">
  <header class="bg-gradient-to-b from-indigo-700 to-indigo-900 dark:from-indigo-900 dark:to-indigo-950">
    <div class="max-w-7xl mx-auto px-4 py-12 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center mb-6">
        <div>
          <h1 class="text-4xl font-bold text-white mb-2 flex items-center">
            <i class="fas fa-map-marked-alt mr-3 text-indigo-300"></i>
            Avalon Roads
          </h1>
          <p class="text-indigo-100 text-lg">
            Explore <span id="total-maps" class="font-semibold">{maps.length}</span> mapas únicos do Avalon
          </p>
          <p class="text-indigo-300 text-sm mt-1 flex items-center">
            <i class="fas fa-clock mr-2"></i>
            Última atualização: {lastUpdated}
          </p>
        </div>
        <ThemeToggle />
      </div>
    </div>
  </header>

  <!-- Banner de anúncio horizontal abaixo do cabeçalho -->
  <div class="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8 mt-6">
    <AdBanner format="horizontal" id="ad-header" adSlot="1234567890" />
  </div>

  <main class="max-w-7xl mx-auto px-4 py-8 sm:px-6 lg:px-8">
    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl border border-gray-200 dark:border-gray-700 p-6 mb-8 mt-5">
      <!-- Filtros superiores -->
      <div class="flex flex-col lg:flex-row gap-4 mb-6">
        <!-- Search Bar - Redesenhada -->
        <div class="relative flex-grow">
          <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none">
            <i class="fas fa-search text-indigo-400 dark:text-indigo-300"></i>
          </div>
          <input 
            type="text" 
            id="search" 
            placeholder="Buscar mapas... (Ctrl + K)" 
            class="w-full px-4 py-3.5 pl-11 bg-gray-50 dark:bg-gray-700/50 border-0 rounded-xl text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 dark:focus:ring-indigo-400 shadow-sm"
          />
          <kbd class="absolute right-4 top-1/2 transform -translate-y-1/2 hidden md:inline-flex px-2 py-1 font-sans text-xs text-gray-500 dark:text-gray-400 border border-gray-300 dark:border-gray-600 rounded">Ctrl+K</kbd>
        </div>

        <!-- Controles de ordenação e filtro redesenhados -->
        <div class="flex gap-3 flex-wrap md:flex-nowrap">
          <!-- Dropdown de tier -->
          <div class="relative min-w-[140px]">
            <select 
              id="tier-filter" 
              class="w-full h-full px-4 py-3.5 bg-gray-50 dark:bg-gray-700/50 border-0 rounded-xl text-gray-900 dark:text-gray-100 appearance-none cursor-pointer focus:ring-2 focus:ring-indigo-500 dark:focus:ring-indigo-400 shadow-sm pl-10"
            >
              <option value="">Todos os Tiers</option>
              {tiers.map(tier => (
                <option value={tier}>Tier {tier}</option>
              ))}
            </select>
            <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-4 text-indigo-400 dark:text-indigo-300">
              <i class="fas fa-layer-group"></i>
            </div>
            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-4 text-gray-400">
              <i class="fas fa-chevron-down text-xs"></i>
            </div>
          </div>

          <!-- Botões de Ordenação -->
          <div class="flex bg-gray-50 dark:bg-gray-700/50 rounded-xl shadow-sm overflow-hidden p-0.5">
            <button 
              id="sort-name" 
              class="px-4 py-3 rounded-lg flex items-center justify-center gap-2 font-medium transition-colors duration-200 hover:text-indigo-600 dark:hover:text-indigo-400 min-w-[120px]"
            >
              <i class="fas fa-sort-alpha-down"></i>
              <span>Por Nome</span>
            </button>
            <button 
              id="sort-tier" 
              class="px-4 py-3 rounded-lg flex items-center justify-center gap-2 font-medium transition-colors duration-200 hover:text-indigo-600 dark:hover:text-indigo-400 min-w-[120px]"
            >
              <i class="fas fa-sort-numeric-down"></i>
              <span>Por Tier</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Resource Filters - Melhorados -->
      <div class="flex flex-wrap gap-2 p-2 bg-gray-50 dark:bg-gray-700/30 rounded-xl" id="resource-filters">
        {allResourceTypes.map(type => (
          <button 
            class="resource-filter px-3 py-2 rounded-full bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 hover:border-indigo-300 dark:hover:border-indigo-500 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition-colors flex items-center gap-2 text-sm text-gray-700 dark:text-gray-200 shadow-sm" 
            data-resource={type}
          >
            <div class="w-6 h-6 bg-gray-50 dark:bg-gray-700 rounded-lg p-1 transition-transform flex items-center justify-center">
              <img 
                src={getResourceIcon(type)} 
                alt={type} 
                class="w-full h-full object-contain"
                loading="lazy"
              />
            </div>
            <span class="font-medium">{type}</span>
          </button>
        ))}
      </div>
    </div>

    <!-- Layout com anúncios -->
    <div class="flex flex-col lg:flex-row gap-6">
      <!-- Conteúdo principal (mapas) -->
      <div class="flex-grow">
        <!-- Loading State -->
        <div id="loading" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-6">
          {Array(6).fill(0).map(() => (
            <div class="map-card bg-white dark:bg-gray-800 p-4 rounded-xl shadow-lg overflow-hidden">
              <div class="flex justify-between items-start mb-3">
                <div class="loading-skeleton h-6 w-32 rounded"></div>
                <div class="loading-skeleton h-6 w-16 rounded-full"></div>
              </div>
              <div class="flex flex-wrap gap-2 min-h-[48px] mb-3">
                {Array(4).fill(0).map(() => (
                  <div class="loading-skeleton h-10 w-10 rounded-lg"></div>
                ))}
              </div>
              <div class="loading-skeleton h-12 w-full rounded-lg"></div>
            </div>
          ))}
        </div>

        <!-- Map List -->
        <div id="map-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-6">
          {maps.map((map, index) => (
            <>
              <div data-map={JSON.stringify(map)} class="map-wrapper">
                <MapCard map={map} />
              </div>
              
              {/* Adicionar anúncio a cada 6 mapas na versão mobile */}
              {index > 0 && (index + 1) % 6 === 0 && (
                <div class="col-span-1 sm:col-span-2 lg:hidden my-2">
                  <AdBanner format="rectangle" id={`ad-in-feed-${Math.floor(index/6)}`} adSlot="6677889900" />
                </div>
              )}
            </>
          ))}
        </div>

        <!-- No Results -->
        <div id="no-results" class="hidden text-center py-16">
          <div class="bg-white dark:bg-gray-800 rounded-xl p-10 max-w-md mx-auto shadow-lg">
            <div class="bg-indigo-100 dark:bg-indigo-900/30 w-20 h-20 rounded-full flex items-center justify-center text-indigo-600 dark:text-indigo-400 mb-6 mx-auto">
              <i class="fas fa-search text-3xl"></i>
            </div>
            <p class="text-xl text-gray-700 dark:text-gray-200 font-medium mb-3">Nenhum mapa encontrado</p>
            <p class="text-gray-500 dark:text-gray-400">Tente ajustar sua busca ou filtros para encontrar o que está procurando.</p>
          </div>
        </div>
      </div>

      <!-- Anúncios na barra lateral (visível apenas em telas grandes) -->
      <div class="hidden lg:block lg:w-[300px] space-y-6 self-start sticky top-6">
        <AdBanner format="sidebar" id="ad-sidebar" adSlot="0987654321" />
        
        <!-- Segundo anúncio retangular para melhor monetização -->
        <AdBanner format="rectangle" id="ad-rectangle" className="mt-8" adSlot="1122334455" />
      </div>
    </div>
    
    <!-- Anúncio horizontal para dispositivos móveis (visível apenas em telas pequenas) -->
    <div class="lg:hidden mt-10">
      <AdBanner format="rectangle" id="ad-mobile" adSlot="5566778899" />
    </div>
  </main>
</Layout>

<script>
  import type { Map, ChestType, DungeonType, ResourceType } from '../types/map';
  
  // State
  let maps: Map[] = [];
  let filteredMaps: Map[] = [];
  let currentSort = { field: 'name', ascending: true };
  let activeFilters = {
    resources: new Set<string>(),
    tier: ''
  };

  // DOM Elements
  const mapList = document.getElementById('map-list')!;
  const loadingElement = document.getElementById('loading')!;
  const noResultsElement = document.getElementById('no-results')!;
  const searchInput = document.getElementById('search') as HTMLInputElement;
  const tierFilter = document.getElementById('tier-filter') as HTMLSelectElement;
  const sortNameButton = document.getElementById('sort-name')!;
  const sortTierButton = document.getElementById('sort-tier')!;
  const resourceFilters = document.querySelectorAll('.resource-filter');
  const totalMapsElement = document.getElementById('total-maps')!;

  // Functions
  const toggleLoading = (show: boolean) => {
    loadingElement.classList.toggle('hidden', !show);
    mapList.classList.toggle('hidden', show);
  };

  // Função auxiliar para verificar se um mapa contém um tipo de recurso
  const mapHasResourceType = (map: Map, resourceType: string): boolean => {
    const hasInChests = map.chests?.some(item => item.type === resourceType) || false;
    const hasInDungeons = map.dungeons?.some(item => item.type === resourceType) || false;
    const hasInResources = map.resources?.some(item => item.type === resourceType) || false;
    return hasInChests || hasInDungeons || hasInResources;
  };

  const updateResourceCounts = () => {
    const counts: Record<string, number> = {};
    
    // Contar todos os tipos de recursos nos mapas filtrados
    filteredMaps.forEach(map => {
      // Contar baús
      map.chests?.forEach(chest => {
        counts[chest.type] = (counts[chest.type] || 0) + 1;
      });
      
      // Contar dungeons
      map.dungeons?.forEach(dungeon => {
        counts[dungeon.type] = (counts[dungeon.type] || 0) + 1;
      });
      
      // Contar recursos
      map.resources?.forEach(resource => {
        counts[resource.type] = (counts[resource.type] || 0) + 1;
      });
    });

    resourceFilters.forEach(button => {
      const resource = button.getAttribute('data-resource')!;
      const countElement = button.querySelector('.resource-count');
      if (countElement) {
        countElement.textContent = String(counts[resource] || 0);
      }
      
      // Update active state
      button.classList.toggle('bg-gray-100', activeFilters.resources.has(resource));
      button.classList.toggle('dark:bg-gray-700', activeFilters.resources.has(resource));
    });

    totalMapsElement.textContent = String(filteredMaps.length);
  };

  const renderMaps = () => {
    const mapElements = document.querySelectorAll('[data-map]');
    mapElements.forEach(el => {
      const map = JSON.parse(el.getAttribute('data-map')!);
      const isVisible = filteredMaps.some(m => m.id === map.id);
      el.classList.toggle('hidden', !isVisible);
    });
  };

  const filterMaps = () => {
    let filtered = [...maps];

    // Apply tier filter
    if (activeFilters.tier) {
      filtered = filtered.filter(map => map.tier === parseInt(activeFilters.tier));
    }

    // Apply resource filters
    if (activeFilters.resources.size > 0) {
      filtered = filtered.filter(map => 
        Array.from(activeFilters.resources).some(resourceType => 
          mapHasResourceType(map, resourceType)
        )
      );
    }

    // Apply search filter
    const searchTerm = searchInput.value.trim().toLowerCase();
    if (searchTerm) {
      filtered = filtered.filter(map => {
        // Verificar nome do mapa completo
        const fullNameMatch = map.name.toLowerCase().includes(searchTerm);
        
        // Verificar recursos
        const resourceMatch = 
          map.chests?.some(r => r.type.toLowerCase().includes(searchTerm)) ||
          map.dungeons?.some(r => r.type.toLowerCase().includes(searchTerm)) ||
          map.resources?.some(r => r.type.toLowerCase().includes(searchTerm));
        
        // Verificar iniciais/partes do nome com hífen
        let initialsMatch = false;
        if (searchTerm.includes('-')) {
          // Extrai as partes da pesquisa (ex: "c-u" => ["c", "u"])
          const searchParts = searchTerm.split('-').map(part => part.trim()).filter(Boolean);
          
          // Extrai as partes do nome do mapa (ex: "Cases-Ugumlos" => ["Cases", "Ugumlos"])
          const nameParts = map.name.split('-').map(part => part.trim()).filter(Boolean);
          
          // Verifica se o número de partes é o mesmo e se cada parte começa com a inicial correspondente
          if (searchParts.length <= nameParts.length) {
            initialsMatch = searchParts.every((searchPart, index) => {
              // Verifica se a parte do nome começa com o termo de busca ou se a inicial coincide
              const namePart = nameParts[index].toLowerCase();
              return namePart.startsWith(searchPart);
            });
          }
        }
        
        return fullNameMatch || resourceMatch || initialsMatch;
      });
    }

    filteredMaps = filtered;
    noResultsElement.classList.toggle('hidden', filteredMaps.length > 0);
    mapList.classList.toggle('hidden', filteredMaps.length === 0);

    updateResourceCounts();
    renderMaps();
  };

  const updateSortButtons = () => {
    [sortNameButton, sortTierButton].forEach(button => {
      button.classList.remove('active');
    });
    
    const activeButton = currentSort.field === 'name' ? sortNameButton : sortTierButton;
    activeButton.classList.add('active');
    
    // Atualiza o ícone conforme a direção da ordenação
    const iconElement = activeButton.querySelector('i');
    if (iconElement) {
      if (currentSort.field === 'name') {
        iconElement.className = currentSort.ascending ? 
          'fas fa-sort-alpha-down' : 
          'fas fa-sort-alpha-up';
      } else {
        iconElement.className = currentSort.ascending ? 
          'fas fa-sort-numeric-down' : 
          'fas fa-sort-numeric-up';
      }
    }
  };

  const sortMaps = (field: 'name' | 'tier') => {
    if (currentSort.field === field) {
      currentSort.ascending = !currentSort.ascending;
    } else {
      currentSort.field = field;
      currentSort.ascending = true;
    }
    
    updateSortButtons();
    
    filteredMaps.sort((a, b) => {
      const aValue = a[field];
      const bValue = b[field];
      const modifier = currentSort.ascending ? 1 : -1;

      if (typeof aValue === 'string') {
        return aValue.localeCompare(bValue as string) * modifier;
      }
      return ((aValue as number) - (bValue as number)) * modifier;
    });

    renderMaps();
  };

  // Inicializar a aparência dos botões de ordenação
  const initializeUI = () => {
    updateSortButtons();
    // Esconder o loading inicialmente
    loadingElement.classList.add('hidden');
  };

  // Event Listeners
  sortNameButton.addEventListener('click', () => sortMaps('name'));
  sortTierButton.addEventListener('click', () => sortMaps('tier'));
  searchInput.addEventListener('input', filterMaps);
  tierFilter.addEventListener('change', (e) => {
    activeFilters.tier = (e.target as HTMLSelectElement).value;
    filterMaps();
  });

  resourceFilters.forEach(button => {
    button.addEventListener('click', () => {
      const resource = button.getAttribute('data-resource')!;
      if (activeFilters.resources.has(resource)) {
        activeFilters.resources.delete(resource);
        button.classList.remove('bg-gray-100', 'dark:bg-gray-700');
      } else {
        activeFilters.resources.add(resource);
        button.classList.add('bg-gray-100', 'dark:bg-gray-700');
      }
      filterMaps();
    });
  });

  // Adicionar atalho de teclado para busca (Ctrl+K)
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      searchInput.focus();
    }
  });

  // Initialize
  const initializeMaps = () => {
    maps = Array.from(document.querySelectorAll('[data-map]')).map(el => 
      JSON.parse(el.getAttribute('data-map')!)
    );
    filteredMaps = [...maps];
    updateResourceCounts();
  };

  // Initialize on page load and after view transitions
  document.addEventListener('astro:page-load', () => {
    initializeMaps();
    initializeUI();
  });
  document.addEventListener('DOMContentLoaded', () => {
    initializeMaps();
    initializeUI();
  });
</script>

<style>
  .loading-skeleton {
    background: linear-gradient(90deg, 
      rgba(var(--tw-skeleton-from, 226, 232, 240), 0.8),
      rgba(var(--tw-skeleton-to, 203, 213, 225), 0.8),
      rgba(var(--tw-skeleton-from, 226, 232, 240), 0.8)
    );
    background-size: 200% 100%;
    animation: loading 1.5s ease-in-out infinite;
  }

  .dark .loading-skeleton {
    --tw-skeleton-from: 42, 50, 69;
    --tw-skeleton-to: 30, 41, 59;
  }

  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
  
  .map-wrapper {
    transition: all 0.3s ease;
  }
  
  /* Estilos para os botões de ordenação */
  #sort-name.active, #sort-tier.active {
    @apply bg-white dark:bg-gray-800 text-indigo-600 dark:text-indigo-400 shadow;
  }
  
  /* Estilo para os filtros de recursos ativos */
  .resource-filter.active {
    @apply bg-indigo-50 dark:bg-indigo-900/40 border-indigo-300 dark:border-indigo-500 text-indigo-700 dark:text-indigo-300;
  }
</style>
